#!/usr/bin/env bash

##
##  Copyright (c) 2023 pobrelkey
##
##  Permission is hereby granted, free of charge, to any person obtaining
##  a copy of this software and associated documentation files (the
##  "Software"), to deal in the Software without restriction, including
##  without limitation the rights to use, copy, modify, merge, publish,
##  distribute, sublicense, and/or sell copies of the Software, and to
##  permit persons to whom the Software is furnished to do so, subject to
##  the following conditions:
##
##  The above copyright notice and this permission notice shall be
##  included in all copies or substantial portions of the Software.
##
##  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
##  KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
##  WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
##  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
##  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
##  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
##  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
##


#
#  git-remote-rclone-sync/-mount: pull and push to Git remotes via rclone
#
#  This remote can operate in either of two ways:
#
#   1. Using "rclone sync", which involves keeping a full local copy of
#      the remote repository.  This is the default, and should in most
#      cases result in fewer accesses/less egress bandwith used.
#
#   2. Using "rclone mount" to access the remote repository via a FUSE
#      filesystem mount.  This trades less local disk usage for more
#      intensive network access.
#
#  Example usages (sync mode):
#
#      git clone rclone-sync::name_of_remote:path/to/repository.git
#      git remote add foo rclone-sync::foo:path/to/foo.git
#
#  Example usages (mount mode):
#
#      git clone rclone-mount::name_of_remote:path/to/repository.git
#      git remote add foo rclone-mount::foo:path/to/foo.git
#
#  The remote location is assumed to contain a Git repository -
#  preferably a bare repository (ordinary repositories should work OK
#  but using these as a remote isn't good practice).
#
#  Neither of the two modes of operation attempts to detect or remedy
#  situations where another process is accessing the remote repository
#  concurrently.  To avoid corruption, only use this tool in use cases
#  where concurrent access is unlikely, or implement your own mechanism
#  to arbitrate access.
#  
#  This script would have just been called "git-remote-rclone", but
#  that name is already taken on GitHub and PyPI by another script
#  which uses a non-standard remote repository format.
#


set -e


if [[ $# == 0 ]]
then
    # TODO: proper usage message
    echo "ERROR: specify --init or let git call this script internally (see \"man gitremote-helpers\")" 1>&2
    exit 1
fi

case "${1}" in
    --password-helper)
        # If the script is invoked with --pasword-helper as the first arg,
        # rclone wants us to prompt the user for a password to its config.
        # Use the git credential helper mechanism to do this.
        RCLONE_CONFIG="${2:-$(rclone config file | sed -ne '/^\//{p;q}')}"
        while true
        do
            # Have git-credential prompt for a password to the rclone config
            # (or get the last-entered password from the credential cache);
            # parse the PASSWORD from the key line of the command's output.
            while read -r LINE
            do
                if [[ "${LINE}" != "${LINE#password=}" ]]
                then
                    PASSWORD="${LINE#password=}"
                fi
            done < <(
                    git credential fill < <(
                            echo protocol=rclone-config
                            echo host=
                            echo path="${RCLONE_CONFIG}"
                            echo username=
                            echo
                        )
                )

            # Test the password by feeding it to rclone, very carefully so as
            # not to expose it as a command line argument or an environment
            # variable (both of which are readable by other userids).
            PIPE_DIR="$(mktemp -d)"
            PIPE="$(mktemp -u -p "${PIPE_DIR}")"
            mkfifo -m 0600 "${PIPE}"
            cat >"${PIPE}" <<<"${PASSWORD}" &
            ECHOER=$!
            VERB=reject
            if rclone config touch \
                    --config "${RCLONE_CONFIG}" \
                    --password-command "cat \"${PIPE//\"/\"\"}\"" \
                    --log-file /dev/null >/dev/null 2>/dev/null
            then
                VERB=approve
            fi
            rm -rf "${PIPE_DIR}"
            disown $ECHOER
            kill $ECHOER >/dev/null 2>/dev/null || true

            # Report back to git-credential whether the password worked
            # (so it should be cache according to local policy) or not
            # (so it should be removed from the cache if it's cached).
            git credential ${VERB} < <(
                    echo protocol=rclone-config
                    echo host=
                    echo path="${RCLONE_CONFIG}"
                    echo username=
                    echo password="${PASSWORD}"
                    echo
                )

            # If the password worked, echo it to stdout so rclone can use it.
            # Else, repeat the while loop and prompt for a new password.
            if [[ $VERB == approve ]]
            then
                echo "${PASSWORD}"
                exit 0
            fi
        done
        ;;


    --init)
        # For convenience: initialize a repository on an rclone remote.
        # (Repositories stored on S3 and other backends with no concept of
        # empty dirs need at least one commit for git to recognize it as a
        # valid repo.  So, we add an initial commit of a Github-style
        # README.md file.)

        SCRIPT_TMPDIR="${TMPDIR:-/tmp}/git-create-rclone-remote-$$"
        cleanup() {
            if [ -d "${SCRIPT_TMPDIR}" ]
            then
                rm -rf "${SCRIPT_TMPDIR}"
            fi
        }
        trap cleanup EXIT

        shift
        REMOTE_URL="$1"
        REPO_NAME="$(basename "${1##*:}" .git)"
        shift

        if [[ -z "${REMOTE_URL}" ]]
        then
            echo 'ERROR: you must specify a remote URL' 1>&2
            exit 1
        fi

        mkdir -p "${SCRIPT_TMPDIR}"

        TMP_BARE_REPOS="${SCRIPT_TMPDIR}/repo"
        git init --bare "${TMP_BARE_REPOS}"
        (
            cd "${TMP_BARE_REPOS}"
            git config gc.autoDetach false
        )

        TMP_WORKING_DIR="${SCRIPT_TMPDIR}/work"
        git clone "${TMP_BARE_REPOS}" "${TMP_WORKING_DIR}" 2>/dev/null
        (
            echo
            echo "# ${REPO_NAME}"
            echo
            echo "$@"
            echo
        ) > "${TMP_WORKING_DIR}"/README.md

        (
            cd "${TMP_WORKING_DIR}"
            git add README.md
            git commit -m 'initial commit'
            git push
        )

        rclone sync --create-empty-src-dirs "${TMP_BARE_REPOS}/" "${REMOTE_URL%/}/"

        exit 0
        ;;


    --fsck|--gc|--repack)
        # TODO
        echo "ERROR: not implemented yet: ${1}" 1>&2
        exit 1
        ;;

    --help)
        # TODO
        echo "ERROR: not implemented yet: ${1}" 1>&2
        exit 1
        ;;

    --version)
        SHA1="$(sed -Ene '/Id: *[0-9a-f]{8}/{s/^.*Id: *([0-9a-f]{8}).*$/\1/p;q};c (unknown version)' <<<'$Id$')"
        echo "$(basename "${0}") ${SHA1}"
        sed -Ene '/^#+ *Copyright/{s/^#+ *//p}' < "${0}"
        echo "License MIT: MIT License <https://spdx.org/licenses/MIT.html>"
        echo "This is free software: you are free to change and redistribute it."
        echo "There is NO WARRANTY, to the extent permitted by law."
        exit 0
        ;;

    --*)
        echo "ERROR: unrecognized option: ${1}" 1>&2
        exit 1

esac



REMOTE_SCHEME="$(basename "${0}")"
REMOTE_SCHEME="${REMOTE_SCHEME#git-remote-}"

# If an rclone config file exists at .git/rclone-sync/rclone.conf,
# use that in preference to the system rclone config file.
if [[ -e "${GIT_DIR}/${REMOTE_SCHEME}/rclone.conf" ]]
then
    export RCLONE_CONFIG="${GIT_DIR}/${REMOTE_SCHEME}/rclone.conf"
fi

# Source .git/rclone-sync/rclone.conf if it exists, to optionally set
# environment variables used by rclone.
if [[ -e "${GIT_DIR}/${REMOTE_SCHEME}/config.env" ]]
then
    . "${GIT_DIR}/${REMOTE_SCHEME}/config.env"
fi

# If no rclone password helper is already specified, tell rclone to
# invoke this script with --password-helper if it needs a password for
# its config file.  (Rclone's built-in password prompt won't work.)
export RCLONE_PASSWORD_COMMAND="${RCLONE_PASSWORD_COMMAND:-\"${0//\"/\"\"}\" --password-helper \"${RCLONE_CONFIG//\"/\"\"}\"}"

if [[ -z "${2}" ]]
then
    REMOTE_URI="${1}"
else
    REMOTE_URI="${2}"
fi

REMOTE_COPY_DIR="${GIT_DIR}/${REMOTE_SCHEME}/remotes/${REMOTE_URI/://}"

while true
do

    read LINE

    if [[ -z "${LINE}" ]]
    then
        exit 0
    fi

    CMD="${LINE%% *}"
    ARG="${LINE#* }"

    case "${CMD}" in

        capabilities)
            echo connect
            echo
            ;;

        connect)
            mkdir -p "${REMOTE_COPY_DIR}" 1>&2
            if [[ "${REMOTE_SCHEME%mount}" != "${REMOTE_SCHEME}" ]]
            then
                function umount_rclone() {
                    # TODO: next line needs to be different on non-Linux OSes
                    fusermount -uz "${REMOTE_COPY_DIR}/" 1>&2
                }
                trap umount_rclone EXIT
                rclone mount "${REMOTE_URI}/" "${REMOTE_COPY_DIR}/" 1>&2 &

                # HACK: wait up to 10s until remote is actually mounted
                for i in $(seq 1 100)
                do
                    if [[ -e "${REMOTE_COPY_DIR}/HEAD" ]] || [[ -e "${REMOTE_COPY_DIR}/.git/HEAD" ]]
                    then
                        break
                    fi
                    sleep 0.1
                done
            else
                find "${REMOTE_COPY_DIR}" -type f '!' -perm -0200 -exec chmod u+w {} +
                rclone sync --create-empty-src-dirs "${REMOTE_URI}/" "${REMOTE_COPY_DIR}/" 1>&2
            fi

            echo
            "${ARG}" "${REMOTE_COPY_DIR}"

            if [[ "${ARG}" != git-upload-pack ]] && [[ "${REMOTE_SCHEME%mount}" == "${REMOTE_SCHEME}" ]]
            then
                rclone sync --create-empty-src-dirs "${REMOTE_COPY_DIR}/" "${REMOTE_URI}/" 1>&2
            fi

            exit 0
            ;;

        *)
            echo "error unrecognized command"
            exit 1
            ;;

    esac

done
